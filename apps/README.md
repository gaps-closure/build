# Cache RPC
Baseline RPC protocol with cache added for faster processing. 
## Semantics

### Assumptions:
* Bidirectional RPC
* Pure function to cache
### Cases it can handle: 
* Cacheing primitive arguments
* Cacheing array arguments
### Features: 
* Developer can indicate whether or not a function has a cache assigned to it
* Developer can choose size of cache to avoid collisions. 

## Usage

### Annotation

* Developers can modify the semantics of the rpc by annotating them with cle-labels during the annotation phase  
* To add a cache, use the cle-labels during the annotation phase. There are two options
```
- cache: accepts yes or no. Yes will generate a cache during RPC generation
- cache_size: optional arguement that sets the size of the cache
```

### Cacheing
* The autogenerated code includes a cache for every function that indicated yes.
* The RPC implementation will automatically return the value if the arguments are stored in the cache.
* The developer can pick and choose which functions are best suited for caches.

## Examples### Primary example: Fibonacci numbers
- Computes fibonacci numbers 2 times.
- If cache enabled, second computation should be much faster
- Disabled cache means 2nd computation takes as much time as 1st computation.

### ChangeList:
- build/src/mules/cle-spec/schema/cle-schema.json : Modifications to support new cle-lables (Cache, cache_size)
- build/src/capo/gedl/RPCGenerator_az.py: Cache RPC generator script 
- build/apps/examples/example3: Fibonacci computation to demonstrate cache compatibility


### Steps to reproduce:
- Update the scripts and schema path in .vscode/closure_env.sh in the example directory to point towards the location of RPCGenerator script and cle-schema respectively. For example, 
```
CLOSURE_TOOLS=/opt/closure
export CLOSURE_SCRIPTS=${CLOSURE_TOOLS}/scripts
export CLOSURE_SCHEMAS=${CLOSURE_TOOLS}/schemas
export RPCGENERATOR=${CLOSURE_SCRIPTS}/RPCGenerator_az.py
```
- Additionally, ensure that the schema and the new RPCGenerator is located in the tools and scripts path.
- Build and run the examples using standard procedure(CLEAN SOURCE, ANNOTATE, ANALYZE PARTITION CONFLICTS, EMULATE) . 
Note: `.solution/refactored` subdirectory in each example contains a sample(working) annotated code. 
