# Steps

  1. Message flow trace: sniffer output  [DONE]
  2. Ingestor for message flow trace: outputs XML for draw.io
  3. Document draw.io conventions (see earlier text) [DONE]
  4. Sample design spec following conventions: Ingest, edit, and save sample output XML
     - components, message flows, message structs, component annotations, message annotations, associated CLE-JSON
  5. C libraries for AMQ and HAL [DONE]
  6. XDCC Code Generator: generate annotated xdcc
     - needs to signal conflicts in design 
     - needs to produce topology.json for divvier
  7. Integrate design GUI into CVI
     - See https://code.visualstudio.com/api/extension-guides/webview
  8. Setup CVI pipeline to handle partitioning of XDCC and test e2e over HAL
     - preferably without modifying tools from what was used at ERI summit!
  9. Stretch demo application

## Immediate Items:

 1. Specify functions that would take in JSON sample/schema and provides GEDL-firendly RPC-wrappable echo function
    - Try to fit within existing RPC generator marshalling capability 
    - GEDL does not handle structs or varags for parameters
 2. Specify functions that would take in stringified JSON (from AMQ) and extract arguments echo function
 3. Specify functions that would take in arguments of echo function and assemble stringified JSON (for posting to AMQ)

# Design of the XDCC Skeleton

// ----------------------------------------------------
// Unpartitioned
// ----------------------------------------------------

// There will be separate versions of each <func>_<MSG>() for each MSG such as updateMissionPlan, pnt, etc.
// These provide separate code paths for each MSG suitable for CLE annotation
// After partitioning echo_MSG will be distributed between the two enclaves, and may be RPC wrapped
// non_local(MSG) will always return false in unpartitioned program, but will return true for some in partitioned program

#define non_local(X) false

echo_MSG(m) 
  amqlib_publish(MSG,m)

egress_MSG(m)
  if non_local(MSG) 
     echo_MSG(m) 

main:
  foreach MSG in all_message_list: 
    setup_amq_listener_MSG(egress_MSG)    // amqlib_create, amqlib_listen
  // housekeep threads before exit

// ----------------------------------------------------
// Partitioned 
// ----------------------------------------------------

// echo_MSG will be distributed to master and slave
// for non_local
//    master receives from AMQ broker and relays to XDC peer (RPC over diode)
//    echo_MSG becomes _rpc_echo_MSG

// ----------------------------------------------------
// Master 
// ----------------------------------------------------

// #undef non_local(MSG) 
// non_local(MSG) function is autogenerated, will return true for remote messages

// includes main, master_thread_MSG, and egress_MSG unmodified for local messages
// includes echo_MSG unmodified only for local messages, omitted for remote messages
// there will be no echo_MSG on this side for remote messages
// for remote messages egress_MSG will be modified and _rpc_echo_MSG will be generated

egress_MSG(m)
  if non_local(MSG) 
     _rpc_echo_MSG(m) 

_rpc_echo_MSG(m):
  // marshalling
  x = jsonstr2idl(MSG,m) // packing/unpacking marshalling/unmarshalling
  xdc_async_send(x)

// ----------------------------------------------------
// Client
// ----------------------------------------------------

// includes echo_MSG unmodified for remote messages
// main, slave_rpc_loop, and handle_echo_MSG are generated

handle_echo_MSG(x)
  xdc_blocking_recv(x)
  m = idl2jsonstr(MSG,x) // packing/unpacking marshalling/unmarshalling
  echo_MSG(m)

slave_rpc_loop():
  foreach MSG in remote list:
    thread(handle_echo_MSG)

  // housekeeping on thread join

main:
  slave_rpc_loop()
  
