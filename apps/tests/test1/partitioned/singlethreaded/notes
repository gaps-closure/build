Limitations:
- does not support loss (will deadlock)
- orange (slave) must be started first
- slave never exits



master  _rpc_get_REQ:
   for k tries:
      sends NEXTTAG
      waits OK (timeout=10); on t/o continue
      recv  OK
      sends REQ
      waits REP (timeout=10); on t/o continue
      recv  REP return success
   return failure


slave:
   forever:
     waits NEXTTAG indefinitely, no timeout
     recv  NEXTTAG
     send  OK
     switch-case
        waits REQ-X (timeout=10); on t/0 continue
        recv  REQ-X
        send  REP-X
   continue

line 2 (NEXTTAG is lost):





master:
  for k tries:
    send REQ reqid
    wait timeout continue
    recv REP for reqid

slave-REQ-handler:
   forever:
     wait REQ reqid
     result = cache(reqid) if reqid in cache else calc(reqid)
     cache(reqid) = result in ring buffer
     send REP for reqid

[reqid3,r3] [reqid,r1] [reqid2,r2]
      

6/22 TODOS
- multithreaded model
- update CLE
    // guardhints have changed (operation)
    // move unused fields in current CLE spec to future (out of mainline json)
    // additional fields for blessed function spec
    // create schema for validation
    // reconsider diode specification use one-way, does that work?
- async push model
- developer/security analysis must review the CLE def for the "blessed" functions
    // argtaints will be list of lists [[<parm1_taints>],{<parm2_taints>],..]
    // parm1_taints is allowed taints for arg#1 of the function, and so on
    // unclear autogeneration can fill in taints, may involve security analyst
    // rettaints is for the return
    // codtaints is for heap/stack/global/data the function touches 
