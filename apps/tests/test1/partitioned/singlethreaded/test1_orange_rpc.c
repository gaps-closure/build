#include "xdcomms.h"
#include "codec.h"
#include "test1_orange_rpc.h"

/* Function ought to be autogenerated by CAPO */
#define TAG_MATCH(X, Y) (X.mux == Y.mux && X.sec == Y.sec && X.typ == Y.typ)
// Move this to RPC file to be autogenerated
// A header file would be needed  get_a can be called.

/* Function ought to be autogenerated by CAPO */
int _slave_rpc_loop() {
  gaps_tag n_tag;
  gaps_tag tag_nexttag, tag_requesta;

  // XXX: move to test_orange main?
  _hal_init((char *)"ipc:///tmp/halsubbworange", (char *)"ipc:///tmp/halpubbwpurple");
 
  // XXX: write tag NEXTTAG into tag_nexttag
  // XXX: write tag REQUESTA into tag_requesta
  tag_requesta.mux = MUX_REQUESTA;
  tag_requesta.sec = SEC_REQUESTA;
  tag_requesta.typ = DATA_TYP_REQUESTA;

  while (1) {
      // XXX: Why bother matching nexttag, can we let that be handled in _get_next_tag, send OK, and use this to handle the returned tag from _get_next_tag?
    _get_next_tag(&n_tag);       // block for NEXTTAG, send OKAY
    if(TAG_MATCH(n_tag, tag_nexttag)) {    // next will be NEXTTAG again, continue
      continue; // XXX: left this for now but i think this case should be removed
    } else if (TAG_MATCH(n_tag, tag_requesta)) {  // next will be REQUESTA
      _handle_requesta(&tag_requesta); // block for REQUESTA, get REQUESTA, run get_a, send RESPONSEA
    } else {
      // unknown/unhandled tag
      // print warning?
      // XXX: TODO
    }    
  }
}

/* Function ought to be autogenerated by CAPO */
void _handle_requesta(gaps_tag* tag_requesta) {
    static int inited = 0;
    static void *psocket;
    static void *ssocket;
    gaps_tag t_tag;
    gaps_tag o_tag;
    requesta_datatype  reqA;
    responsea_datatype resA;
    double a;

    t_tag.mux = tag_requesta->mux;
    t_tag.sec = tag_requesta->sec;
    t_tag.typ = tag_requesta->typ;

    if (!inited) {
      inited = 1;
      psocket = xdc_pub_socket();
      ssocket = xdc_sub_socket(t_tag); 
    }

    xdc_blocking_recv(ssocket, &reqA, &t_tag);
    resA.a = get_a();

    tag_write(&o_tag, MUX_RESPONSEA, SEC_RESPONSEA, DATA_TYP_RESPONSEA);
    xdc_asyn_send(psocket, &resA, &o_tag);
}

/* Function ought to be autogenerated by CAPO */
void _get_next_tag(gaps_tag* n_tag) {
    static int inited = 0;
    static void *psocket;
    static void *ssocket;
    gaps_tag t_tag;
    gaps_tag o_tag;
    nextrpc_datatype nxt;
    okay_datatype okay;

    tag_write(&t_tag, MUX_NEXTRPC, SEC_NEXTRPC, DATA_TYP_NEXTRPC);
    if (!inited) {
      inited = 1;
      psocket = xdc_pub_socket();
      ssocket = xdc_sub_socket(t_tag); 
    }
    xdc_blocking_recv(ssocket, &nxt, &t_tag); 
    // XXX: validate receive?

    tag_write(&o_tag, MUX_OKAY, SEC_OKAY, DATA_TYP_OKAY);
    okay.x = 0;
    xdc_asyn_send(psocket, &okay, &o_tag);

    n_tag->mux = nxt.mux;
    n_tag->sec = nxt.sec;
    n_tag->typ = nxt.typ; 
}

/* Function ought to be autogenerated by CAPO */
void _hal_init(char *inuri, char *outuri)
{
  xdc_set_in(inuri);
  xdc_set_out(outuri);
  xdc_register(nextrpc_data_encode, nextrpc_data_decode, DATA_TYP_NEXTRPC);
  xdc_register(okay_data_encode, okay_data_decode, DATA_TYP_OKAY);
  xdc_register(requesta_data_encode, requesta_data_decode, DATA_TYP_REQUESTA);
  xdc_register(responsea_data_encode, responsea_data_decode, DATA_TYP_RESPONSEA);
}


/*
while true:
  block for 1,1,99       // tag here for SYNCTAG1
  receive   1,1,99 gets next_ tag expected (e.g., 1,1,1)
  send      1,1,100 <OK> // tag here for SYNCTAG2

  switch (next_tag)
     case (1,1,1):
        block for 1,1,1                // tag here for matching TAG1
        run function with 1,1,1 data and get result
        send result with tag 1,1,2     //tag here for matching TAG2
        continue

     case(1,1,9):
        ...
     continue
*/